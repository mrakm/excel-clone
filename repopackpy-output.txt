================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-03T22:49:45.937541

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
app/
  excel/
    page.tsx
  favicon.ico
  globals.css
  layout.tsx
  page.tsx
components/
  Cell.tsx
  CellEditor.tsx
  ExcelClone.tsx
  Footer.tsx
  Grid.tsx
  Header.tsx
context/
  ExcelContext.tsx
hooks/
  useExcelHandlers.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
types/
  excel.ts
utils/
  excelUtils.ts
  formulaUtils.ts
.prettierrc
README.md
next.config.js
package.json
postcss.config.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
}

module.exports = nextConfig

================
File: README.md
================
# Excel Clone with TypeScript and Next.js

A feature-rich spreadsheet application built with TypeScript, Next.js, and React window for virtualization. This project demonstrates best practices for building complex web applications with modern JavaScript frameworks.

## Features

- Formula support with proper reference handling
- Cell selection with keyboard navigation
- Fill handle for formula dragging and copying
- Virtualized grid for handling large spreadsheets
- Type-safe code with TypeScript
- Component-based architecture
- Context API for state management
- Custom hooks for logic separation
- Responsive design with Tailwind CSS

## Technical Overview

### Architecture

This Excel clone is built with a component-based architecture, following modern React best practices:

- **Context-based State Management**: Using React Context API to manage application state
- **Component Separation**: Components are separated by responsibility
- **Custom Hooks**: Logic is extracted into custom hooks for better reusability
- **Virtualization**: Using React Window to render only visible cells for performance
- **TypeScript**: Full type safety throughout the application

### Key Components

- `ExcelProvider`: Manages the global state and provides context to all components
- `Grid`: Renders the virtualized grid with react-window
- `Cell`: Individual cell component with selection and editing capabilities
- `Header`: Contains the formula bar and application controls
- `Footer`: Displays metadata and additional controls

### Formula Handling

The application includes full formula support:

- Formula parsing and evaluation
- Cell reference resolution
- Circular reference detection
- Automatic recalculation when dependencies change
- Formula dragging with smart cell reference adjustment

## Getting Started

### Prerequisites

- Node.js 14.x or later
- npm or yarn

### Installation

1. Clone the repository
2. Install dependencies:

```bash
npm install
# or
yarn install
```

3. Start the development server:

```bash
npm run dev
# or
yarn dev
```

4. Open [http://localhost:3000](http://localhost:3000) in your browser

## Usage

- Type in cells just like in Excel
- Use formulas starting with '=' (e.g., =A1+B1)
- Click and drag to select multiple cells
- Drag from the bottom-right corner of a cell to copy formulas
- Use arrow keys for navigation
- Press Enter to commit changes and move down
- Press Tab to move right

## Project Structure

```
excel-clone-typescript/
├── app/                    # Next.js app directory
│   ├── excel/              # Excel application route
│   ├── globals.css         # Global styles
│   ├── layout.tsx          # Root layout
│   └── page.tsx            # Landing page
├── components/             # React components
│   ├── Cell.tsx            # Individual cell component
│   ├── CellEditor.tsx      # Formula editor
│   ├── ExcelClone.tsx      # Main application component
│   ├── Footer.tsx          # Application footer
│   ├── Grid.tsx            # Virtualized grid
│   └── Header.tsx          # Application header
├── context/                # React context
│   └── ExcelContext.tsx    # Global state management
├── hooks/                  # Custom React hooks
│   └── useExcelHandlers.ts # Input handling logic
├── types/                  # TypeScript type definitions
│   └── excel.ts            # Excel-related types
├── utils/                  # Utility functions
│   ├── excelUtils.ts       # General Excel utilities
│   └── formulaUtils.ts     # Formula processing utilities
└── [Configuration files]   # Various config files
```

## License

MIT

================
File: package.json
================
{
  "name": "excel-clone-typescript",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "format": "prettier --write \"**/*.{ts,tsx,css,json}\""
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-window": "^1.8.9"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-window": "^1.8.5",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.0",
    "postcss": "^8.4.30",
    "prettier": "^3.0.0",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.0.0"
  }
}

================
File: .prettierrc
================
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "arrowParens": "avoid"
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: types/excel.ts
================
// Basic cell position type
export interface CellPosition {
  row: number;
  col: number;
}

// Grid dimensions
export interface GridSize {
  rows: number;
  cols: number;
}

// Viewport state
export interface Viewport {
  startRow: number;
  startCol: number;
  visibleRows: number;
  visibleCols: number;
}

// Cell selection state
export interface CellSelectionState {
  selectionStart: CellPosition | null;
  selectionEnd: CellPosition | null;
  isMouseDown: boolean;
}

// Dragging state
export interface DraggingState {
  isDragging: boolean;
  dragOrigin: CellPosition | null;
  dragTarget: CellPosition | null;
}

// Main data storage type
export type CellData = Record<string, string | number>;

// Excel Formula Type
export interface FormulaHelpers {
  evaluateFormula: (formula: string, cellAddress: string, visitedCells?: Set<string>) => string | number;
  adjustCellReferences: (formula: string, rowDiff: number, colDiff: number) => string;
  parseCellReference: (ref: string) => CellPosition | null;
  getColumnLabel: (col: number) => string;
}

// Cell helpers
export interface CellHelpers {
  getCellDisplayValue: (row: number, col: number) => string | number;
  isCellSelected: (row: number, col: number) => boolean;
  getSelectionRange: () => string;
}

// Excel context type for the provider
export interface ExcelContextType {
  // Data
  data: CellData;
  setData: React.Dispatch<React.SetStateAction<CellData>>;
  
  // Active cell
  activeCell: CellPosition | null;
  setActiveCell: React.Dispatch<React.SetStateAction<CellPosition | null>>;
  
  // Edit value
  editValue: string;
  setEditValue: React.Dispatch<React.SetStateAction<string>>;
  
  // Grid dimensions
  gridSize: GridSize;
  setGridSize: React.Dispatch<React.SetStateAction<GridSize>>;
  
  // Viewport
  viewport: Viewport;
  setViewport: React.Dispatch<React.SetStateAction<Viewport>>;
  
  // Selection
  selectionStart: CellPosition | null;
  setSelectionStart: React.Dispatch<React.SetStateAction<CellPosition | null>>;
  selectionEnd: CellPosition | null;
  setSelectionEnd: React.Dispatch<React.SetStateAction<CellPosition | null>>;
  
  // Mouse state
  isMouseDown: boolean;
  setIsMouseDown: React.Dispatch<React.SetStateAction<boolean>>;
  
  // Dragging
  isDragging: boolean;
  setIsDragging: React.Dispatch<React.SetStateAction<boolean>>;
  dragOrigin: CellPosition | null;
  setDragOrigin: React.Dispatch<React.SetStateAction<CellPosition | null>>;
  dragTarget: CellPosition | null;
  setDragTarget: React.Dispatch<React.SetStateAction<CellPosition | null>>;
  
  // Formula helpers
  parseCellReference: (ref: string) => CellPosition | null;
  adjustCellReferences: (formula: string, rowDiff: number, colDiff: number) => string;
  evaluateFormula: (formula: string, cellAddress: string, visitedCells?: Set<string>) => string | number;
  
  // Cell helpers
  getColumnLabel: (col: number) => string;
  getCellDisplayValue: (row: number, col: number) => string | number;
  isCellSelected: (row: number, col: number) => boolean;
  getSelectionRange: () => string;
  
  // Event handlers
  handleCellSelect: (row: number, col: number, isShiftKey?: boolean) => void;
  handleScroll: (direction: 'vertical' | 'horizontal', amount: number) => void;
  addThousandRows: () => void;
}

================
File: context/ExcelContext.tsx
================
import React, { createContext, useContext, useState, useCallback, ReactNode, useRef, useEffect } from 'react';
import { 
  CellPosition, 
  CellData, 
  GridSize, 
  Viewport, 
  ExcelContextType 
} from '@/types/excel';

// Create the context with a default value
const ExcelContext = createContext<ExcelContextType | undefined>(undefined);

interface ExcelProviderProps {
  children: ReactNode;
}

export const ExcelProvider: React.FC<ExcelProviderProps> = ({ children }) => {
  // State for storing cell data
  const [data, setData] = useState<CellData>({});
  
  // State for tracking which cell is being edited
  const [activeCell, setActiveCell] = useState<CellPosition | null>(null);
  
  // State for the content being edited
  const [editValue, setEditValue] = useState<string>('');
  
  // State for grid dimensions
  const [gridSize, setGridSize] = useState<GridSize>({ rows: 1000, cols: 100 });
  
  // State for viewport position
  const [viewport, setViewport] = useState<Viewport>({ 
    startRow: 0, 
    startCol: 0, 
    visibleRows: 20, 
    visibleCols: 10 
  });
  
  // State for selection range
  const [selectionStart, setSelectionStart] = useState<CellPosition | null>(null);
  const [selectionEnd, setSelectionEnd] = useState<CellPosition | null>(null);
  
  // State for tracking if mouse is down (for drag selection)
  const [isMouseDown, setIsMouseDown] = useState<boolean>(false);
  
  // State for formula dragging
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [dragOrigin, setDragOrigin] = useState<CellPosition | null>(null);
  const [dragTarget, setDragTarget] = useState<CellPosition | null>(null);

  // Convert column number to Excel-style column label (A, B, C, ..., Z, AA, AB, ...)
  const getColumnLabel = useCallback((col: number): string => {
    let label = '';
    let c = col;
    
    do {
      c = Math.max(0, c);
      label = String.fromCharCode(65 + (c % 26)) + label;
      c = Math.floor(c / 26) - 1;
    } while (c >= 0);
    
    return label;
  }, []);

  // Convert cell reference (e.g., "A1") to row and column indices
  const parseCellReference = useCallback((ref: string): CellPosition | null => {
    const match = ref.match(/([A-Z]+)(\d+)/);
    if (!match) return null;
    
    const colLabel = match[1];
    const row = parseInt(match[2], 10) - 1;
    
    let col = 0;
    for (let i = 0; i < colLabel.length; i++) {
      col = col * 26 + (colLabel.charCodeAt(i) - 64);
    }
    col -= 1; // Convert to 0-indexed
    
    return { row, col };
  }, []);

  // Adjust formula references when copying/dragging
  const adjustCellReferences = useCallback((formula: string, rowDiff: number, colDiff: number): string => {
    if (!formula.startsWith('=')) return formula;
    
    // Regular expression to find cell references
    const cellRefRegex = /([A-Z]+)(\d+)/g;
    
    // Replace each cell reference with adjusted reference
    return formula.replace(cellRefRegex, (match, colRef, rowRef) => {
      // Adjust row
      const newRow = parseInt(rowRef, 10) + rowDiff;
      
      // Adjust column
      let colNum = 0;
      for (let i = 0; i < colRef.length; i++) {
        colNum = colNum * 26 + (colRef.charCodeAt(i) - 64);
      }
      
      const newColNum = colNum + colDiff;
      if (newColNum <= 0) return match; // Don't adjust if it would go out of bounds
      
      // Convert back to column reference
      let newColRef = '';
      let tempColNum = newColNum;
      
      do {
        tempColNum--;
        newColRef = String.fromCharCode(65 + (tempColNum % 26)) + newColRef;
        tempColNum = Math.floor(tempColNum / 26);
      } while (tempColNum > 0);
      
      return newColRef + newRow;
    });
  }, []);

  // Evaluate a formula
  const evaluateFormula = useCallback((
    formula: string, 
    cellAddress: string, 
    visitedCells: Set<string> = new Set()
  ): string | number => {
    // Remove the leading equals sign
    const expression = formula.substring(1).trim();
    
    // Replace cell references with their values
    const cellRefRegex = /([A-Z]+\d+)/g;
    const cellRefs = expression.match(cellRefRegex) || [];
    
    // Check for circular references
    if (cellRefs.includes(cellAddress) || visitedCells.has(cellAddress)) {
      return '#CIRCULAR!';
    }
    
    // Add current cell to visited cells to detect circular references
    visitedCells.add(cellAddress);
    
    let evaluatedExpression = expression;
    
    for (const ref of cellRefs) {
      const position = parseCellReference(ref);
      if (!position) continue;
      
      const { row, col } = position;
      const cellKey = `${row},${col}`;
      const cellValue = data[cellKey] || '';
      
      // If the reference is to a cell with a formula, evaluate it recursively
      if (typeof cellValue === 'string' && cellValue.startsWith('=')) {
        try {
          const evaluatedValue = evaluateFormula(cellValue, ref, new Set(visitedCells));
          evaluatedExpression = evaluatedExpression.replace(new RegExp(ref, 'g'), String(evaluatedValue));
        } catch (error) {
          return '#ERROR!';
        }
      } else {
        // For non-formula cells, just use the value
        const numericValue = isNaN(Number(cellValue)) ? 0 : Number(cellValue);
        evaluatedExpression = evaluatedExpression.replace(new RegExp(ref, 'g'), String(numericValue));
      }
    }
    
    // Evaluate the resulting expression
    try {
      // Use Function constructor to evaluate the mathematical expression
      // eslint-disable-next-line no-new-func
      const result = new Function(`return ${evaluatedExpression}`)();
      return typeof result === 'number' ? parseFloat(result.toFixed(10)) : result;
    } catch (error) {
      return '#ERROR!';
    }
  }, [data, parseCellReference]);

  // Get the displayed value for a cell
  const getCellDisplayValue = useCallback((row: number, col: number): string | number => {
    const cellKey = `${row},${col}`;
    const value = data[cellKey] || '';
    
    if (typeof value === 'string' && value.startsWith('=')) {
      try {
        const cellAddress = `${getColumnLabel(col)}${row + 1}`;
        return evaluateFormula(value, cellAddress);
      } catch (error) {
        return '#ERROR!';
      }
    }
    
    return value;
  }, [data, evaluateFormula, getColumnLabel]);

  // Check if a cell is within the current selection range
  const isCellSelected = useCallback((row: number, col: number): boolean => {
    if (!selectionStart || !selectionEnd) return false;
    
    const minRow = Math.min(selectionStart.row, selectionEnd.row);
    const maxRow = Math.max(selectionStart.row, selectionEnd.row);
    const minCol = Math.min(selectionStart.col, selectionEnd.col);
    const maxCol = Math.max(selectionStart.col, selectionEnd.col);
    
    return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;
  }, [selectionStart, selectionEnd]);

  // Get the current selection range as a string (e.g., "A1:B3")
  const getSelectionRange = useCallback((): string => {
    if (!selectionStart || !selectionEnd) return '';
    
    const startLabel = `${getColumnLabel(selectionStart.col)}${selectionStart.row + 1}`;
    const endLabel = `${getColumnLabel(selectionEnd.col)}${selectionEnd.row + 1}`;
    
    return startLabel === endLabel ? startLabel : `${startLabel}:${endLabel}`;
  }, [selectionStart, selectionEnd, getColumnLabel]);

  // Handle cell selection
  const handleCellSelect = useCallback((row: number, col: number, isShiftKey = false): void => {
    // If there's an active cell, commit its value first
    if (activeCell) {
      const { row: activeRow, col: activeCol } = activeCell;
      const activeCellKey = `${activeRow},${activeCol}`;
      
      // Update data for the previous active cell
      setData(prevData => {
        const newData = {
          ...prevData,
          [activeCellKey]: editValue
        };
        return newData;
      });
      
      // Force re-evaluation of all formulas
      setTimeout(() => {
        setData(prevData => ({...prevData}));
      }, 0);
    }
    
    if (isShiftKey && selectionStart) {
      // Extend selection if shift key is pressed
      setSelectionEnd({ row, col });
    } else {
      // Start a new selection
      setSelectionStart({ row, col });
      setSelectionEnd({ row, col });
    }
    
    // Set active cell for editing
    setActiveCell({ row, col });
    const cellKey = `${row},${col}`;
    setEditValue(String(data[cellKey] || ''));
  }, [selectionStart, data, activeCell, editValue]);

  // Handle scroll to adjust viewport
  const handleScroll = useCallback((direction: 'vertical' | 'horizontal', amount: number): void => {
    setViewport(prev => {
      if (direction === 'vertical') {
        return {
          ...prev,
          startRow: Math.max(0, prev.startRow + amount)
        };
      } else {
        return {
          ...prev,
          startCol: Math.max(0, prev.startCol + amount)
        };
      }
    });
  }, []);
  
  // Add 1000 rows to the grid
  const addThousandRows = useCallback((): void => {
    setGridSize(prev => ({
      ...prev,
      rows: prev.rows + 1000
    }));
  }, []);

  const value: ExcelContextType = {
    // Data
    data,
    setData,
    
    // Active cell
    activeCell,
    setActiveCell,
    
    // Edit value
    editValue,
    setEditValue,
    
    // Grid dimensions
    gridSize,
    setGridSize,
    
    // Viewport
    viewport,
    setViewport,
    
    // Selection
    selectionStart,
    setSelectionStart,
    selectionEnd,
    setSelectionEnd,
    
    // Mouse state
    isMouseDown,
    setIsMouseDown,
    
    // Dragging
    isDragging,
    setIsDragging,
    dragOrigin,
    setDragOrigin,
    dragTarget,
    setDragTarget,
    
    // Formula helpers
    parseCellReference,
    adjustCellReferences,
    evaluateFormula,
    
    // Cell helpers
    getColumnLabel,
    getCellDisplayValue,
    isCellSelected,
    getSelectionRange,
    
    // Event handlers
    handleCellSelect,
    handleScroll,
    addThousandRows,
  };

  return (
    <ExcelContext.Provider value={value}>
      {children}
    </ExcelContext.Provider>
  );
};

// Custom hook for using the Excel context
export const useExcelContext = (): ExcelContextType => {
  const context = useContext(ExcelContext);
  if (context === undefined) {
    throw new Error('useExcelContext must be used within an ExcelProvider');
  }
  return context;
};

================
File: app/layout.tsx
================
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Excel Clone in TypeScript and Next.js',
  description: 'A virtualized Excel clone built with TypeScript and Next.js',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

================
File: app/page.tsx
================
import Link from 'next/link';

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <div className="max-w-5xl w-full text-center">
        <h1 className="text-4xl font-bold mb-6">Excel Clone in TypeScript and Next.js</h1>
        <p className="text-lg mb-8">
          A fully functional virtualized Excel clone with formula support, cell selection, and data manipulation
        </p>
        <Link 
          href="/excel" 
          className="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg text-lg font-medium transition-colors"
        >
          Launch Excel Clone
        </Link>
      </div>
    </main>
  );
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: white;
}

/* Custom styling for Excel clone */
.cell-active {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  z-index: 5;
}

.fill-handle {
  position: absolute;
  width: 8px;
  height: 8px;
  background-color: #3b82f6;
  bottom: 0;
  right: 0;
  cursor: crosshair;
}

.cell-selected {
  background-color: rgba(59, 130, 246, 0.1);
}

.cell-dragging {
  background-color: rgba(34, 197, 94, 0.1);
}

================
File: app/excel/page.tsx
================
'use client';

import React from 'react';
import { ExcelProvider } from '@/context/ExcelContext';
import ExcelClone from '@/components/ExcelClone';

export default function ExcelPage() {
  return (
    <ExcelProvider>
      <ExcelClone />
    </ExcelProvider>
  );
}

================
File: utils/formulaUtils.ts
================
import { CellData } from '@/types/excel';
import { parseCellReference, getColumnLabel, safeEvaluate } from './excelUtils';

/**
 * Adjust formula references when copying/dragging
 */
export const adjustCellReferences = (formula: string, rowDiff: number, colDiff: number): string => {
  if (!formula.startsWith('=')) return formula;
  
  // Regular expression to find cell references
  const cellRefRegex = /([A-Z]+)(\d+)/g;
  
  // Replace each cell reference with adjusted reference
  return formula.replace(cellRefRegex, (match, colRef, rowRef) => {
    // Adjust row
    const newRow = parseInt(rowRef, 10) + rowDiff;
    
    // Adjust column
    let colNum = 0;
    for (let i = 0; i < colRef.length; i++) {
      colNum = colNum * 26 + (colRef.charCodeAt(i) - 64);
    }
    
    const newColNum = colNum + colDiff;
    if (newColNum <= 0) return match; // Don't adjust if it would go out of bounds
    
    // Convert back to column reference
    let newColRef = '';
    let tempColNum = newColNum;
    
    do {
      tempColNum--;
      newColRef = String.fromCharCode(65 + (tempColNum % 26)) + newColRef;
      tempColNum = Math.floor(tempColNum / 26);
    } while (tempColNum > 0);
    
    return newColRef + newRow;
  });
};

/**
 * Evaluate a formula
 */
export const evaluateFormula = (
  formula: string, 
  cellAddress: string, 
  data: CellData, 
  visitedCells: Set<string> = new Set()
): string | number => {
  // Remove the leading equals sign
  const expression = formula.substring(1).trim();
  
  // Replace cell references with their values
  const cellRefRegex = /([A-Z]+\d+)/g;
  const cellRefs = expression.match(cellRefRegex) || [];
  
  // Check for circular references
  if (cellRefs.includes(cellAddress) || visitedCells.has(cellAddress)) {
    return '#CIRCULAR!';
  }
  
  // Add current cell to visited cells to detect circular references
  visitedCells.add(cellAddress);
  
  let evaluatedExpression = expression;
  
  for (const ref of cellRefs) {
    const position = parseCellReference(ref);
    if (!position) continue;
    
    const { row, col } = position;
    const cellKey = `${row},${col}`;
    const cellValue = data[cellKey] || '';
    
    // If the reference is to a cell with a formula, evaluate it recursively
    if (typeof cellValue === 'string' && cellValue.startsWith('=')) {
      try {
        const evaluatedValue = evaluateFormula(cellValue, ref, data, new Set(visitedCells));
        evaluatedExpression = evaluatedExpression.replace(new RegExp(ref, 'g'), String(evaluatedValue));
      } catch (error) {
        return '#ERROR!';
      }
    } else {
      // For non-formula cells, just use the value
      const numericValue = isNaN(Number(cellValue)) ? 0 : Number(cellValue);
      evaluatedExpression = evaluatedExpression.replace(new RegExp(ref, 'g'), String(numericValue));
    }
  }
  
  return safeEvaluate(evaluatedExpression);
};

/**
 * Get the displayed value for a cell
 */
export const getCellDisplayValue = (row: number, col: number, data: CellData): string | number => {
  const cellKey = `${row},${col}`;
  const value = data[cellKey] || '';
  
  if (typeof value === 'string' && value.startsWith('=')) {
    try {
      const cellAddress = `${getColumnLabel(col)}${row + 1}`;
      return evaluateFormula(value, cellAddress, data);
    } catch (error) {
      return '#ERROR!';
    }
  }
  
  return value;
};

================
File: utils/excelUtils.ts
================
import { CellPosition } from '@/types/excel';

/**
 * Convert column number to Excel-style column label (A, B, C, ..., Z, AA, AB, ...)
 */
export const getColumnLabel = (col: number): string => {
  let label = '';
  let c = col;
  
  do {
    c = Math.max(0, c);
    label = String.fromCharCode(65 + (c % 26)) + label;
    c = Math.floor(c / 26) - 1;
  } while (c >= 0);
  
  return label;
};

/**
 * Convert cell reference (e.g., "A1") to row and column indices
 */
export const parseCellReference = (ref: string): CellPosition | null => {
  const match = ref.match(/([A-Z]+)(\d+)/);
  if (!match) return null;
  
  const colLabel = match[1];
  const row = parseInt(match[2], 10) - 1;
  
  let col = 0;
  for (let i = 0; i < colLabel.length; i++) {
    col = col * 26 + (colLabel.charCodeAt(i) - 64);
  }
  col -= 1; // Convert to 0-indexed
  
  return { row, col };
};

/**
 * Checks if a cell is within the current selection range
 */
export const isCellInSelectionRange = (
  row: number, 
  col: number, 
  selectionStart: CellPosition | null, 
  selectionEnd: CellPosition | null
): boolean => {
  if (!selectionStart || !selectionEnd) return false;
  
  const minRow = Math.min(selectionStart.row, selectionEnd.row);
  const maxRow = Math.max(selectionStart.row, selectionEnd.row);
  const minCol = Math.min(selectionStart.col, selectionEnd.col);
  const maxCol = Math.max(selectionStart.col, selectionEnd.col);
  
  return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;
};

/**
 * Checks if a cell is within a drag selection range
 */
export const isCellInDragRange = (
  row: number, 
  col: number, 
  dragOrigin: CellPosition | null, 
  dragTarget: CellPosition | null
): boolean => {
  if (!dragOrigin || !dragTarget) return false;
  
  const minRow = Math.min(dragOrigin.row, dragTarget.row);
  const maxRow = Math.max(dragOrigin.row, dragTarget.row);
  const minCol = Math.min(dragOrigin.col, dragTarget.col);
  const maxCol = Math.max(dragOrigin.col, dragTarget.col);
  
  return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;
};

/**
 * Get the selection range as a string (e.g., "A1:B3")
 */
export const getSelectionRangeString = (
  selectionStart: CellPosition | null, 
  selectionEnd: CellPosition | null
): string => {
  if (!selectionStart || !selectionEnd) return '';
  
  const startLabel = `${getColumnLabel(selectionStart.col)}${selectionStart.row + 1}`;
  const endLabel = `${getColumnLabel(selectionEnd.col)}${selectionEnd.row + 1}`;
  
  return startLabel === endLabel ? startLabel : `${startLabel}:${endLabel}`;
};

/**
 * Safely evaluate a mathematical expression
 */
export const safeEvaluate = (expression: string): number | string => {
  try {
    // Use Function constructor to evaluate the mathematical expression
    // eslint-disable-next-line no-new-func
    const result = new Function(`return ${expression}`)();
    return typeof result === 'number' ? parseFloat(result.toFixed(10)) : result;
  } catch (error) {
    return '#ERROR!';
  }
};

================
File: components/CellEditor.tsx
================
import React, { useEffect, useRef } from 'react';
import { useExcelContext } from '@/context/ExcelContext';

interface CellEditorProps {
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleInputBlur: () => void;
  handleKeyPress: (e: React.KeyboardEvent) => void;
}

const CellEditor: React.FC<CellEditorProps> = ({
  handleInputChange,
  handleInputBlur,
  handleKeyPress,
}) => {
  const { 
    activeCell, 
    editValue, 
    getColumnLabel,
    selectionStart,
    selectionEnd,
    getSelectionRange
  } = useExcelContext();
  
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    // Focus the input when activeCell changes
    if (activeCell && inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeCell]);

  if (!activeCell) {
    return null;
  }

  const cellLabel = selectionStart && selectionEnd && 
    (selectionStart.row !== selectionEnd.row || selectionStart.col !== selectionEnd.col) 
      ? getSelectionRange() 
      : `${getColumnLabel(activeCell.col)}${activeCell.row + 1}`;

  return (
    <div className="flex space-x-2 mt-2">
      <div className="bg-white border px-2 py-1">
        {cellLabel}
      </div>
      <input
        ref={inputRef}
        type="text"
        className="border px-2 py-1 flex-grow"
        value={editValue}
        onChange={handleInputChange}
        onBlur={handleInputBlur}
        onKeyPress={handleKeyPress}
        placeholder="Enter value or formula"
      />
    </div>
  );
};

export default CellEditor;

================
File: components/Grid.tsx
================
import React, { useCallback, useRef, useEffect } from 'react';
import { FixedSizeGrid as VirtualGrid } from 'react-window';
import { useExcelContext } from '@/context/ExcelContext';
import Cell from '@/components/Cell';

const Grid: React.FC = () => {
  const { 
    gridSize,
    viewport,
    setViewport,
    activeCell,
    editValue,
    handleCellSelect,
    getColumnLabel,
    getCellDisplayValue,
    isCellSelected,
    isDragging,
    dragOrigin,
    dragTarget,
    isMouseDown,
    setIsMouseDown,
    setIsDragging,
    setDragOrigin,
    setDragTarget,
    setData,
    data,
    adjustCellReferences,
    setEditValue,
    handleScroll
  } = useExcelContext();
  
  const gridRef = useRef<VirtualGrid>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Handle mouse down on a cell
  const handleMouseDown = useCallback((row: number, col: number, e: React.MouseEvent): void => {
    e.preventDefault(); // Prevent text selection
    
    // If we're clicking on a different cell, commit current cell's edits first
    if (activeCell && (activeCell.row !== row || activeCell.col !== col)) {
      const { row: activeRow, col: activeCol } = activeCell;
      const activeCellKey = `${activeRow},${activeCol}`;
      
      // Update data for the previous active cell
      if (data[activeCellKey] !== editValue) {
        setData(prevData => {
          const newData = {
            ...prevData,
            [activeCellKey]: editValue
          };
          return newData;
        });
        
        // Force re-evaluation of all formulas
        setTimeout(() => {
          setData(prevData => ({...prevData}));
        }, 0);
      }
    }
    
    setIsMouseDown(true);
    
    // Check if this is the bottom-right corner of the active cell (for dragging)
    const target = e.currentTarget as HTMLDivElement;
    const isFillHandleArea = activeCell && 
      activeCell.row === row && 
      activeCell.col === col &&
      e.nativeEvent.offsetX > target.clientWidth - 10 && 
      e.nativeEvent.offsetY > target.clientHeight - 10;
    
    if (isFillHandleArea) {
      setIsDragging(true);
      setDragOrigin({ row, col });
      setDragTarget({ row, col });
    } else {
      // Handle selection
      handleCellSelect(row, col, e.shiftKey);
    }
  }, [handleCellSelect, activeCell, data, editValue, setIsMouseDown, setIsDragging, setDragOrigin, setDragTarget, setData]);

  // Handle mouse enter on a cell (for drag selection)
  const handleMouseEnter = useCallback((row: number, col: number): void => {
    if (isMouseDown) {
      if (isDragging) {
        setDragTarget({ row, col });
      } else if (activeCell) {
        handleCellSelect(activeCell.row, activeCell.col, true);
        // Update the selection end
        setViewport(prev => {
          let newViewport = { ...prev };
          
          if (row < prev.startRow) {
            newViewport.startRow = row;
          } else if (row >= prev.startRow + prev.visibleRows) {
            newViewport.startRow = row - prev.visibleRows + 1;
          }
          
          if (col < prev.startCol) {
            newViewport.startCol = col;
          } else if (col >= prev.startCol + prev.visibleCols) {
            newViewport.startCol = col - prev.visibleCols + 1;
          }
          
          return newViewport;
        });
      }
    }
  }, [isMouseDown, isDragging, activeCell, handleCellSelect, setDragTarget, setViewport]);

  // Handle mouse up (end selection or dragging)
  const handleMouseUp = useCallback(() => {
    // If we were dragging, apply the formula to all cells in the range
    if (isDragging && dragOrigin && dragTarget) {
      const originCellKey = `${dragOrigin.row},${dragOrigin.col}`;
      const sourceFormula = String(data[originCellKey] || '');
      
      // Determine the range of cells to fill
      const minRow = Math.min(dragOrigin.row, dragTarget.row);
      const maxRow = Math.max(dragOrigin.row, dragTarget.row);
      const minCol = Math.min(dragOrigin.col, dragTarget.col);
      const maxCol = Math.max(dragOrigin.col, dragTarget.col);
      
      // Create new data with adjusted formulas for each cell in the range
      const newData = { ...data };
      
      for (let r = minRow; r <= maxRow; r++) {
        for (let c = minCol; c <= maxCol; c++) {
          // Skip the original cell
          if (r === dragOrigin.row && c === dragOrigin.col) continue;
          
          const rowDiff = r - dragOrigin.row;
          const colDiff = c - dragOrigin.col;
          const cellKey = `${r},${c}`;
          
          // Adjust formula references for the new position
          if (sourceFormula.startsWith('=')) {
            newData[cellKey] = adjustCellReferences(sourceFormula, rowDiff, colDiff);
          } else {
            // For non-formulas, just copy the value
            newData[cellKey] = sourceFormula;
          }
        }
      }
      
      // Update the data state
      setData(newData);
      
      // Force re-evaluation of all formulas
      setTimeout(() => {
        setData(prevData => ({...prevData}));
      }, 0);
    }
    
    setIsMouseDown(false);
    setIsDragging(false);
    setDragOrigin(null);
    setDragTarget(null);
  }, [isDragging, dragOrigin, dragTarget, data, adjustCellReferences, setData, setIsMouseDown, setIsDragging, setDragOrigin, setDragTarget]);

  // Handle input change
  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>): void => {
    setEditValue(e.target.value);
  }, [setEditValue]);

  // Handle input blur (finish editing)
  const handleInputBlur = useCallback((): void => {
    if (activeCell) {
      const { row, col } = activeCell;
      const cellKey = `${row},${col}`;
      
      // Only update if value has changed - necessary to prevent double triggers
      if (data[cellKey] !== editValue) {
        // Update the data state
        setData(prevData => {
          const newData = {
            ...prevData,
            [cellKey]: editValue
          };
          return newData;
        });
        
        // Force re-evaluation of all formulas
        setTimeout(() => {
          setData(prevData => ({...prevData}));
        }, 0);
      }
    }
  }, [activeCell, editValue, data, setData]);

  // Handle key press in the input
  const handleKeyPress = useCallback((e: React.KeyboardEvent): void => {
    if (e.key === 'Enter') {
      // Apply the current edit
      if (activeCell) {
        const { row, col } = activeCell;
        const cellKey = `${row},${col}`;
        
        // Update the data state
        setData(prevData => {
          const newData = {
            ...prevData,
            [cellKey]: editValue
          };
          return newData;
        });
        
        // Force re-evaluation of all formulas
        setTimeout(() => {
          setData(prevData => ({...prevData}));
        }, 0);
      }
      
      // Move to the next row
      if (activeCell) {
        const { row, col } = activeCell;
        handleCellSelect(row + 1, col);
      }
    }
  }, [activeCell, editValue, handleCellSelect, setData]);

  // Handle navigation keys
  const handleKeyDown = useCallback((e: React.KeyboardEvent): void => {
    if (!activeCell) return;
    
    const { row, col } = activeCell;
    let newRow = row;
    let newCol = col;
    let handled = false;
    
    switch (e.key) {
      case 'ArrowUp':
        newRow = Math.max(0, row - 1);
        handled = true;
        break;
      case 'ArrowDown':
        newRow = row + 1;
        handled = true;
        break;
      case 'ArrowLeft':
        newCol = Math.max(0, col - 1);
        handled = true;
        break;
      case 'ArrowRight':
        newCol = col + 1;
        handled = true;
        break;
      case 'Tab':
        e.preventDefault(); // This is critical to prevent default tab behavior
        e.stopPropagation(); // This ensures the event doesn't bubble up
        newCol = col + 1;
        handled = true;
        break;
      default:
        return;
    }
    
    // Only proceed if we handled a navigation key
    if (handled) {
      // Apply the current edit to the cell
      if (activeCell) {
        const cellKey = `${row},${col}`;
        
        // Update the data state
        setData(prevData => {
          const newData = {
            ...prevData,
            [cellKey]: editValue
          };
          return newData;
        });
        
        // Force re-evaluation of all formulas
        setTimeout(() => {
          setData(prevData => ({...prevData}));
        }, 0);
      }
      
      // Handle selection with Shift key
      if (e.shiftKey) {
        // If there's no selection yet, start one from the current cell
        if (!activeCell) return;
        handleCellSelect(newRow, newCol, true);
      } else {
        // Move to the new cell (without extending selection)
        handleCellSelect(newRow, newCol);
      }
    }
  }, [activeCell, editValue, handleCellSelect, setData]);

  // Handle grid scroll events
  const handleGridScroll = useCallback(({ scrollTop, scrollLeft }: { scrollTop: number, scrollLeft: number }): void => {
    const newStartRow = Math.floor(scrollTop / 35);
    const newStartCol = Math.floor(scrollLeft / 100);
    
    setViewport(prev => ({
      ...prev,
      startRow: newStartRow,
      startCol: newStartCol
    }));
  }, [setViewport]);

  // Set up global event listeners for keyboard navigation and mouse interactions
  useEffect(() => {
    const handleGlobalMouseUp = () => {
      handleMouseUp();
    };
    
    const handleKeyboardEvents = (e: KeyboardEvent) => {
      // Only handle navigation keys when not typing in an input
      // Check if the active element is not an input
      if (activeCell && 
          document.activeElement !== inputRef.current &&
          (e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
           e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        handleKeyDown(e as unknown as React.KeyboardEvent);
      }
    };
    
    window.addEventListener('mouseup', handleGlobalMouseUp);
    window.addEventListener('keydown', handleKeyboardEvents);
    
    return () => {
      window.removeEventListener('mouseup', handleGlobalMouseUp);
      window.removeEventListener('keydown', handleKeyboardEvents);
    };
  }, [activeCell, handleKeyDown, handleMouseUp]);

  // Render the cell component for the virtual grid
  const renderCell = useCallback(({ columnIndex, rowIndex, style }: { columnIndex: number, rowIndex: number, style: React.CSSProperties }) => {
    return (
      <Cell
        rowIndex={rowIndex}
        columnIndex={columnIndex}
        style={style}
        getColumnLabel={getColumnLabel}
        activeCell={activeCell}
        editValue={editValue}
        handleMouseDown={handleMouseDown}
        handleMouseEnter={handleMouseEnter}
        handleInputChange={handleInputChange}
        handleInputBlur={handleInputBlur}
        handleKeyPress={handleKeyPress}
        handleKeyDown={handleKeyDown}
        getCellDisplayValue={getCellDisplayValue}
        isCellSelected={isCellSelected}
        isDragging={isDragging}
        dragOrigin={dragOrigin}
        dragTarget={dragTarget}
        inputRef={inputRef}
      />
    );
  }, [
    getColumnLabel,
    activeCell,
    editValue,
    handleMouseDown,
    handleMouseEnter,
    handleInputChange,
    handleInputBlur,
    handleKeyPress,
    handleKeyDown,
    getCellDisplayValue,
    isCellSelected,
    isDragging,
    dragOrigin,
    dragTarget,
  ]);

  return (
    <div className="flex-grow overflow-hidden relative">
      <div className="flex absolute top-2 right-2 z-10">
        <div className="mr-2">
          <button 
            className="bg-gray-200 p-2 border"
            onClick={() => handleScroll('vertical', -5)}
          >
            ▲
          </button>
          <button 
            className="bg-gray-200 p-2 border mt-1"
            onClick={() => handleScroll('vertical', 5)}
          >
            ▼
          </button>
        </div>
        <div>
          <button 
            className="bg-gray-200 p-2 border"
            onClick={() => handleScroll('horizontal', -5)}
          >
            ◀
          </button>
          <button 
            className="bg-gray-200 p-2 border ml-1"
            onClick={() => handleScroll('horizontal', 5)}
          >
            ▶
          </button>
        </div>
      </div>
      
      <VirtualGrid
        ref={gridRef}
        className="border-collapse"
        columnCount={gridSize.cols + 1} // +1 for row headers
        columnWidth={100}
        height={window.innerHeight - 150} // Adjust based on header/footer height
        rowCount={gridSize.rows + 1} // +1 for column headers
        rowHeight={35}
        width={window.innerWidth}
        onScroll={handleGridScroll}
        style={{ overflow: 'auto' }}
      >
        {renderCell}
      </VirtualGrid>
    </div>
  );
};

export default Grid;

================
File: components/Footer.tsx
================
import React from 'react';
import { useExcelContext } from '@/context/ExcelContext';

const Footer: React.FC = () => {
  const { 
    viewport,
    getColumnLabel,
    selectionStart,
    selectionEnd,
    getSelectionRange,
    addThousandRows
  } = useExcelContext();

  return (
    <div className="p-2 bg-gray-100 border-t">
      <div className="flex justify-between items-center">
        <div className="text-sm text-gray-600">
          Position: Row {viewport.startRow + 1} to {viewport.startRow + viewport.visibleRows}, 
          Column {getColumnLabel(viewport.startCol)} to {getColumnLabel(viewport.startCol + viewport.visibleCols - 1)}
        </div>
        {selectionStart && selectionEnd && (
          <div className="text-sm text-gray-600 mx-2">
            Selected: {getSelectionRange()}
          </div>
        )}
        <button
          className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded"
          onClick={addThousandRows}
        >
          Add 1000 Rows
        </button>
      </div>
    </div>
  );
};

export default Footer;

================
File: components/Cell.tsx
================
import React, { RefObject } from 'react';
import { CellPosition, CellSelectionState } from '@/types/excel';

interface CellProps {
  rowIndex: number;
  columnIndex: number;
  style: React.CSSProperties;
  getColumnLabel: (col: number) => string;
  activeCell: CellPosition | null;
  editValue: string;
  handleMouseDown: (row: number, col: number, e: React.MouseEvent) => void;
  handleMouseEnter: (row: number, col: number) => void;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleInputBlur: () => void;
  handleKeyPress: (e: React.KeyboardEvent) => void;
  handleKeyDown: (e: React.KeyboardEvent) => void;
  getCellDisplayValue: (row: number, col: number) => string | number;
  isCellSelected: (row: number, col: number) => boolean;
  isDragging: boolean;
  dragOrigin: CellPosition | null;
  dragTarget: CellPosition | null;
  inputRef: RefObject<HTMLInputElement>;
}

const Cell: React.FC<CellProps> = ({
  rowIndex,
  columnIndex,
  style,
  getColumnLabel,
  activeCell,
  editValue,
  handleMouseDown,
  handleMouseEnter,
  handleInputChange,
  handleInputBlur,
  handleKeyPress,
  handleKeyDown,
  getCellDisplayValue,
  isCellSelected,
  isDragging,
  dragOrigin,
  dragTarget,
  inputRef,
}) => {
  // Adjust for the header row and column
  const actualRowIndex = rowIndex - 1;
  const actualColIndex = columnIndex - 1;
  
  // Handle the corner cell (top-left)
  if (rowIndex === 0 && columnIndex === 0) {
    return (
      <div 
        style={style}
        className="bg-gray-200 border p-1 text-center sticky top-0 left-0 z-10 flex items-center justify-center"
      >
      </div>
    );
  }
  
  // Handle the header row (column labels)
  if (rowIndex === 0) {
    return (
      <div 
        style={style}
        className="bg-gray-200 border p-1 text-center sticky top-0 z-10 flex items-center justify-center"
      >
        {getColumnLabel(actualColIndex)}
      </div>
    );
  }
  
  // Handle the header column (row labels)
  if (columnIndex === 0) {
    return (
      <div 
        style={style}
        className="bg-gray-200 border p-1 text-center sticky left-0 z-10 flex items-center justify-center"
      >
        {actualRowIndex + 1}
      </div>
    );
  }
  
  // Regular cells
  const isActive = activeCell && activeCell.row === actualRowIndex && activeCell.col === actualColIndex;
  const isSelected = isCellSelected(actualRowIndex, actualColIndex);
  const isDragCell = isDragging && dragOrigin && dragTarget && 
    actualRowIndex >= Math.min(dragOrigin.row, dragTarget.row) && 
    actualRowIndex <= Math.max(dragOrigin.row, dragTarget.row) && 
    actualColIndex >= Math.min(dragOrigin.col, dragTarget.col) && 
    actualColIndex <= Math.max(dragOrigin.col, dragTarget.col);
  
  return (
    <div 
      style={style}
      className={`border p-0 ${
        isActive ? 'bg-blue-100' : 
        isDragCell ? 'bg-green-50' :
        isSelected ? 'bg-blue-50' : 
        'bg-white'
      }`}
      onMouseDown={(e) => handleMouseDown(actualRowIndex, actualColIndex, e)}
      onMouseEnter={() => handleMouseEnter(actualRowIndex, actualColIndex)}
    >
      {isActive ? (
        <div className="relative w-full h-full">
          <input
            ref={inputRef}
            type="text"
            className="w-full h-full p-1 outline-none border-none"
            value={editValue}
            onChange={handleInputChange}
            onBlur={handleInputBlur}
            onKeyPress={handleKeyPress}
            onKeyDown={(e) => {
              if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                handleKeyDown(e);
              }
            }}
          />
          {/* Fill handle for dragging */}
          <div 
            className="absolute bg-blue-500 right-0 bottom-0 cursor-crosshair"
            style={{ 
              width: '8px', 
              height: '8px',
              bottom: '0px',
              right: '0px',
            }}
          ></div>
        </div>
      ) : (
        <div className="p-1 overflow-hidden text-ellipsis">
          {getCellDisplayValue(actualRowIndex, actualColIndex)}
        </div>
      )}
    </div>
  );
};

export default React.memo(Cell);

================
File: components/Header.tsx
================
import React from 'react';
import CellEditor from './CellEditor';

interface HeaderProps {
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleInputBlur: () => void;
  handleKeyPress: (e: React.KeyboardEvent) => void;
}

const Header: React.FC<HeaderProps> = ({
  handleInputChange,
  handleInputBlur,
  handleKeyPress
}) => {
  return (
    <div className="p-2 bg-gray-100 border-b">
      <h1 className="text-xl font-semibold">Excel Clone (TypeScript + Next.js)</h1>
      <p className="text-sm text-gray-600">
        Type formulas starting with = (example: =A1+B1) | Click and drag to select cells | Drag from cell corner to copy formulas
      </p>
      <CellEditor 
        handleInputChange={handleInputChange}
        handleInputBlur={handleInputBlur}
        handleKeyPress={handleKeyPress}
      />
    </div>
  );
};

export default Header;

================
File: components/ExcelClone.tsx
================
import React from 'react';
import dynamic from 'next/dynamic';
import useExcelHandlers from '@/hooks/useExcelHandlers';
import Header from '@/components/Header';
import Footer from '@/components/Footer';

// Dynamically import the Grid component with SSR disabled
// This is necessary because react-window uses window which is not available during SSR
const Grid = dynamic(() => import('@/components/Grid'), { ssr: false });

const ExcelClone: React.FC = () => {
  const { handleInputChange, handleInputBlur, handleKeyPress } = useExcelHandlers();

  return (
    <div className="flex flex-col h-screen max-h-screen">
      <Header 
        handleInputChange={handleInputChange}
        handleInputBlur={handleInputBlur}
        handleKeyPress={handleKeyPress}
      />
      <Grid />
      <Footer />
    </div>
  );
};

export default ExcelClone;

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: hooks/useExcelHandlers.ts
================
import { useCallback } from 'react';
import { useExcelContext } from '@/context/ExcelContext';

export const useExcelHandlers = () => {
  const {
    activeCell,
    editValue,
    setData,
    setEditValue,
    handleCellSelect
  } = useExcelContext();

  // Handle input change
  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>): void => {
    setEditValue(e.target.value);
  }, [setEditValue]);

  // Handle input blur (finish editing)
  const handleInputBlur = useCallback((): void => {
    if (activeCell) {
      const { row, col } = activeCell;
      const cellKey = `${row},${col}`;
      
      // Update the data state
      setData(prevData => {
        // Only update if value has changed
        if (prevData[cellKey] === editValue) {
          return prevData;
        }
        
        const newData = {
          ...prevData,
          [cellKey]: editValue
        };
        return newData;
      });
      
      // Force re-evaluation of all formulas
      setTimeout(() => {
        setData(prevData => ({...prevData}));
      }, 0);
    }
  }, [activeCell, editValue, setData]);

  // Handle key press in the input
  const handleKeyPress = useCallback((e: React.KeyboardEvent): void => {
    if (e.key === 'Enter') {
      // Apply the current edit
      if (activeCell) {
        const { row, col } = activeCell;
        const cellKey = `${row},${col}`;
        
        // Update the data state
        setData(prevData => {
          const newData = {
            ...prevData,
            [cellKey]: editValue
          };
          return newData;
        });
        
        // Force re-evaluation of all formulas
        setTimeout(() => {
          setData(prevData => ({...prevData}));
        }, 0);
      }
      
      // Move to the next row
      if (activeCell) {
        const { row, col } = activeCell;
        handleCellSelect(row + 1, col);
      }
    }
  }, [activeCell, editValue, handleCellSelect, setData]);

  return {
    handleInputChange,
    handleInputBlur,
    handleKeyPress
  };
};

export default useExcelHandlers;
